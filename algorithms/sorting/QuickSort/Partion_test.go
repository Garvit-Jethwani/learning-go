// ********RoostGPT********
/*
Test generated by RoostGPT for test go-claude using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=partion_85ec5b49db
ROOST_METHOD_SIG_HASH=partion_04016b5112

================================VULNERABILITIES================================
Vulnerability: CWE-20: Improper Input Validation
Issue: The 'partion' function does not validate the input parameters 'low' and 'high'. This could lead to out-of-bounds access if the caller provides invalid indices.
Solution: Add input validation to ensure 'low' and 'high' are within the valid range of indices for the 'arr' slice. Panic or return an error if the indices are invalid.

Vulnerability: CWE-476: NULL Pointer Dereference
Issue: If an empty slice is passed as 'arr', accessing 'arr[high]' will cause a runtime panic due to out-of-bounds access.
Solution: Check if the 'arr' slice is empty before accessing elements. Return an error or handle the case appropriately if 'arr' is empty.

================================================================================
Here are the test scenarios for the given `partion` function in the `QuickSort` package:

Scenario 1: Partition an array with distinct elements

Details:
  Description: This test verifies that the `partion` function correctly partitions an array with distinct elements around a pivot element.
Execution:
  Arrange: Create an input array `arr` with distinct elements and set `low` and `high` indices appropriately.
  Act: Invoke the `partion` function with the arranged input array, low index, and high index.
  Assert: Verify that the elements in the array are partitioned correctly around the pivot element, and the function returns the correct index of the pivot element.
Validation:
  The assertion should check that all elements to the left of the pivot are less than the pivot, and all elements to the right are greater than or equal to the pivot. The test is important to ensure the basic functionality of the partition step in the QuickSort algorithm.

Scenario 2: Partition an array with duplicate elements

Details:
  Description: This test checks if the `partion` function correctly handles an array containing duplicate elements.
Execution:
  Arrange: Create an input array `arr` with duplicate elements and set `low` and `high` indices appropriately.
  Act: Invoke the `partion` function with the arranged input array, low index, and high index.
  Assert: Verify that the elements in the array are partitioned correctly around the pivot element, and the function returns the correct index of the pivot element.
Validation:
  The assertion should check that all elements to the left of the pivot are less than or equal to the pivot, and all elements to the right are greater than or equal to the pivot. This test is important to ensure the partition function works correctly with duplicate elements.

Scenario 3: Partition an array with a single element

Details:
  Description: This test verifies that the `partion` function correctly handles an array with a single element.
Execution:
  Arrange: Create an input array `arr` with a single element and set `low` and `high` indices to 0.
  Act: Invoke the `partion` function with the arranged input array, low index, and high index.
  Assert: Verify that the function returns 0, indicating that the single element is the pivot.
Validation:
  The assertion should check that the returned index is 0. This test is important to ensure the partition function handles the base case of a single-element array correctly.

Scenario 4: Partition an empty array

Details:
  Description: This test checks if the `partion` function correctly handles an empty array.
Execution:
  Arrange: Create an empty input array `arr` and set `low` and `high` indices to 0.
  Act: Invoke the `partion` function with the arranged empty array, low index, and high index.
  Assert: Verify that the function returns -1, indicating that the array is empty and no partitioning is possible.
Validation:
  The assertion should check that the returned index is -1. This test is important to ensure the partition function handles the case of an empty array gracefully and does not cause any runtime errors or unexpected behavior.

Scenario 5: Partition an array with all elements equal to the pivot

Details:
  Description: This test verifies that the `partion` function correctly handles an array where all elements are equal to the pivot element.
Execution:
  Arrange: Create an input array `arr` with all elements equal to the pivot element and set `low` and `high` indices appropriately.
  Act: Invoke the `partion` function with the arranged input array, low index, and high index.
  Assert: Verify that the function returns the index of the last element in the array.
Validation:
  The assertion should check that the returned index is equal to `high`. This test is important to ensure the partition function handles the case where all elements are equal to the pivot correctly and does not cause any infinite loops or unexpected behavior.

Scenario 6: Partition an array with negative elements

Details:
  Description: This test checks if the `partion` function correctly handles an array containing negative elements.
Execution:
  Arrange: Create an input array `arr` with negative elements and set `low` and `high` indices appropriately.
  Act: Invoke the `partion` function with the arranged input array, low index, and high index.
  Assert: Verify that the elements in the array are partitioned correctly around the pivot element, and the function returns the correct index of the pivot element.
Validation:
  The assertion should check that all elements to the left of the pivot are less than the pivot, and all elements to the right are greater than or equal to the pivot. This test is important to ensure the partition function works correctly with negative elements and does not cause any unexpected behavior.

These test scenarios cover various cases, including normal operation, edge cases, and potential error scenarios, to ensure the robustness and correctness of the `partion` function in the `QuickSort` package.
*/

// ********RoostGPT********
package QuickSort

import (
	"testing"
)

func TestPartion(t *testing.T) {
	testCases := []struct {
		name           string
		arr            []int
		low, high      int
		expectedIndex  int
		expectedArray  []int
	}{
		{
			name:           "Partition an array with distinct elements",
			arr:            []int{5, 2, 9, 1, 7, 6, 3},
			low:            0,
			high:           6,
			expectedIndex:  3,
			expectedArray:  []int{2, 1, 3, 5, 7, 6, 9},
		},
		{
			name:           "Partition an array with duplicate elements",
			arr:            []int{4, 2, 4, 1, 4, 6, 3},
			low:            0,
			high:           6,
			expectedIndex:  3,
			expectedArray:  []int{2, 1, 3, 4, 4, 6, 4},
		},
		{
			name:           "Partition an array with a single element",
			arr:            []int{5},
			low:            0,
			high:           0,
			expectedIndex:  0,
			expectedArray:  []int{5},
		},
		{
			name:           "Partition an empty array",
			arr:            []int{},
			low:            0,
			high:           0,
			expectedIndex:  -1,
			expectedArray:  []int{},
		},
		{
			name:           "Partition an array with all elements equal to the pivot",
			arr:            []int{3, 3, 3, 3, 3},
			low:            0,
			high:           4,
			expectedIndex:  4,
			expectedArray:  []int{3, 3, 3, 3, 3},
		},
		{
			name:           "Partition an array with negative elements",
			arr:            []int{-5, -2, -9, -1, -7, -6, -3},
			low:            0,
			high:           6,
			expectedIndex:  3,
			expectedArray:  []int{-9, -7, -6, -5, -2, -1, -3},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actualIndex := partion(tc.arr, tc.low, tc.high)
			if actualIndex != tc.expectedIndex {
				t.Errorf("Expected index: %d, but got: %d", tc.expectedIndex, actualIndex)
			}

			if !isArrayEqual(tc.arr, tc.expectedArray) {
				t.Errorf("Expected array: %v, but got: %v", tc.expectedArray, tc.arr)
			}
		})
	}
}

func isArrayEqual(arr1, arr2 []int) bool {
	if len(arr1) != len(arr2) {
		return false
	}
	for i := 0; i < len(arr1); i++ {
		if arr1[i] != arr2[i] {
			return false
		}
	}
	return true
}
